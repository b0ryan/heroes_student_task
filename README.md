# Heroes Battle - Реализация алгоритмов

Проект содержит реализацию четырех алгоритмов для игры Heroes Battle.

## Реализованные алгоритмы

### 1. GeneratePresetImpl - Генерация пресета армии

**Алгоритм:** Жадный алгоритм (Greedy Algorithm) с предварительной сортировкой

**Описание:**
Алгоритм формирует оптимальную армию компьютера, максимизируя соотношение атаки к стоимости и здоровья к стоимости. Используется жадный подход: сначала рассчитывается эффективность каждого типа юнита, затем они сортируются по убыванию эффективности, и выбираются наиболее эффективные юниты до достижения ограничений.

**Основные шаги:**
1. Расчет эффективности каждого типа юнита: `эффективность = 0.6 * (атака/стоимость) + 0.4 * (здоровье/стоимость)`
2. Сортировка юнитов по убыванию эффективности
3. Жадный выбор: добавление наиболее эффективных юнитов до достижения лимита (11 юнитов каждого типа, максимум 1500 очков)

**Алгоритмическая сложность:**
- **Временная сложность:** O(n log n + m), где:
  - `n` - количество типов юнитов (обычно 4)
  - `m` - максимальное количество юнитов в армии
  - O(n log n) - сортировка эффективности
  - O(m) - жадный выбор юнитов
- **Пространственная сложность:** O(n + m)
  - O(n) - хранение эффективности и счетчиков
  - O(m) - список выбранных юнитов

**Соответствие требованиям:** ✅ O(n log n) или лучше, где n - число типов юнитов, m - максимальное число юнитов в армии

---

### 2. SimulateBattleImpl - Симуляция боя

**Алгоритм:** Пошаговая симуляция с динамической сортировкой

**Описание:**
Алгоритм проводит симуляцию боя между армиями игрока и компьютера. На каждом раунде все живые юниты сортируются по убыванию атаки, затем каждый юнит делает ход. Бой продолжается до тех пор, пока в обеих армиях есть живые юниты или пока не будет сделан хотя бы один ход.

**Основные шаги:**
1. Получение всех живых юнитов из обеих армий
2. Сортировка юнитов по убыванию атаки
3. Последовательное выполнение ходов каждого юнита
4. Логирование каждой атаки
5. Повтор до завершения боя

**Алгоритмическая сложность:**
- **Временная сложность:** O(r * m log m), где:
  - `r` - количество раундов боя
  - `m` - общее количество юнитов в обеих армиях
  - O(m log m) - сортировка юнитов на каждом раунде
  - O(m) - выполнение ходов (метод `attack()` работает за O(m))
- **Пространственная сложность:** O(m)
  - Хранение списка всех юнитов

**Соответствие требованиям:** ✅ O(m log m) или лучше, где m - общее количество юнитов в армии (при условии, что метод атаки работает за O(m))

---

### 3. SuitableForAttackUnitsFinderImpl - Поиск подходящих для атаки юнитов

**Алгоритм:** Линейный проход с проверкой блокировки

**Описание:**
Алгоритм определяет список юнитов противника, доступных для атаки. Юнит считается доступным, если он не заблокирован другими юнитами своей армии. Для армии компьютера проверяется, не закрыт ли юнит справа (y+1), для армии игрока - слева (y-1).

**Основные шаги:**
1. Для каждого ряда юнитов противника:
   - Создание множества занятых координат Y
   - Проверка каждого юнита на блокировку
   - Добавление незаблокированных юнитов в результат

**Алгоритмическая сложность:**
- **Временная сложность:** O(n), где:
  - `n` - общее количество юнитов во всех рядах
  - O(n) - один проход по всем юнитам для создания множества занятых координат
  - O(n) - второй проход для проверки блокировки
  - Операции с HashSet: O(1) в среднем случае
- **Пространственная сложность:** O(n)
  - Множество занятых координат: O(n) в худшем случае
  - Список подходящих юнитов: O(n)

**Соответствие требованиям:** ✅ O(n) или лучше, где n - количество юнитов в рядах (линейная сложность на двумерной плоскости)

---

### 4. UnitTargetPathFinderImpl - Поиск кратчайшего пути

**Алгоритм:** Поиск в ширину (BFS - Breadth-First Search)

**Описание:**
Алгоритм находит кратчайший путь между атакующим и целевым юнитом на игровом поле с препятствиями. Используется алгоритм BFS, который гарантирует нахождение кратчайшего пути в невзвешенном графе. Движение разрешено в 8 направлениях (включая диагональ).

**Основные шаги:**
1. Инициализация препятствий (занятые клетки другими юнитами)
2. BFS от начальной позиции:
   - Добавление начальной клетки в очередь
   - Пока очередь не пуста:
     - Извлечение текущей клетки
     - Если достигнута цель - восстановление пути
     - Проверка всех 8 соседних клеток
     - Добавление непосещенных и свободных клеток в очередь
3. Восстановление пути от цели к началу

**Алгоритмическая сложность:**
- **Временная сложность:** O(WIDTH * HEIGHT + n), где:
  - `WIDTH` = 27, `HEIGHT` = 21 (размеры игрового поля)
  - `n` - количество юнитов в списке препятствий
  - O(n) - создание множества препятствий
  - O(WIDTH * HEIGHT) - BFS в худшем случае посещает все клетки поля
  - O(WIDTH * HEIGHT) - проверка до 8 соседей для каждой клетки
  - Операции с HashMap и HashSet: O(1) в среднем случае
- **Пространственная сложность:** O(WIDTH * HEIGHT)
  - Очередь BFS: O(WIDTH * HEIGHT) в худшем случае
  - Множество посещенных клеток: O(WIDTH * HEIGHT)
  - Множество препятствий: O(n)

**Соответствие требованиям:** ✅ O(WIDTH * HEIGHT) или лучше, где WIDTH = 27, HEIGHT = 21

---

## Общая информация

### Структура проекта
```
src/programs/
├── GeneratePresetImpl.java          # Генерация армии
├── SimulateBattleImpl.java           # Симуляция боя
├── SuitableForAttackUnitsFinderImpl.java  # Поиск доступных целей
└── UnitTargetPathFinderImpl.java     # Поиск пути
```

### Сборка проекта

Для сборки проекта в JAR файл выполните:

```bash
# Компиляция
javac -cp "libs/heroes_task_lib-1.0-SNAPSHOT.jar" -d build src/programs/*.java

# Создание JAR
jar cf obf.jar -C build programs
```

Результирующий файл `obf.jar` необходимо поместить в папку `heroes\jars` для использования в игре.

---

## Примечания

- Все алгоритмы включают проверки на null и валидацию входных данных
- Реализации оптимизированы для соответствия требованиям по алгоритмической сложности
- Используются стандартные структуры данных Java (ArrayList, HashMap, HashSet) для оптимальной производительности

